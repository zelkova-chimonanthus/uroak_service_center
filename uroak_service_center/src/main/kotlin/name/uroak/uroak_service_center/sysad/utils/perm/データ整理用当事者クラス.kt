package name.uroak.uroak_service_center.sysad.utils.perm

import name.uroak.uroak_service_center.shared.constants.message.メッセージID一覧
import name.uroak.uroak_service_center.shared.error.exception.実行権限チェックエラークラス
import name.uroak.uroak_service_center.sysad.constants.権限管理定数
import name.uroak.uroak_service_center.sysad.utils.perm.perm_data.データ整理用利用対象クラス
import name.uroak.uroak_service_center.sysad.utils.perm.perm_data.データ整理用実行権限設定データクラス
import name.uroak.uroak_service_center.sysad.utils.実行権限当事者種別一覧.利用対象
import name.uroak.uroak_service_center.sysad.utils.実行権限当事者種別一覧.利用者
import name.uroak.uroak_service_center.sysad.utils.実行権限利用対象種別一覧
import name.uroak.uroak_service_center.sysad.utils.実行権限利用対象種別一覧.*
import name.uroak.uroak_service_center.sysad.utils.実行権限利用者種別一覧
import name.uroak.uroak_service_center.sysad.utils.実行権限当事者種別一覧
import name.uroak.uroak_service_center.sysad.utils.権限属性クラス

/**
 *
 */
abstract class データ整理用当事者クラス(private val 識別子: Int, private val 当事者種別: 実行権限当事者種別一覧) {

    /***/
    private var 権限データ配列 = mutableListOf<データ整理用実行権限設定データクラス>()

    /***/
    private val 権限データ識別子セット = mutableSetOf<Int>()

    /**【利用者側権限分類】権限設定データの利用対象が手続きの権限設定データを登録したマップ（利用対象IDがキー）*/
    private val 利用対象別権限データマップ_手続き = mutableMapOf<Int, データ整理用実行権限設定データクラス>()

    /**【利用者側権限分類】権限設定データの利用対象が手続き目録の権限設定データを登録したマップ（利用対象IDがキー）*/
    private val 利用対象別権限データマップ_手続き目録 = mutableMapOf<Int, データ整理用実行権限設定データクラス>()

    /**【利用者側権限分類】権限設定データの利用対象が手続きグループの権限設定データを登録したマップ（利用対象IDがキー）*/
    private val 利用対象別権限データマップ_手続きグループ = mutableMapOf<Int, データ整理用実行権限設定データクラス>()

    /***/
    private var 権限対象手続き_権限: 権限属性クラス? = null

    /***/
    private var 権限対象手続き目録_階層別権限 = mutableMapOf<Int, 権限属性クラス>()

    /***/
    private var 権限対象手続きグループ_手続き権限: 権限属性クラス? = null

    /***/
    private var 権限対象手続きグループ_階層別権限 = mutableMapOf<Int, 権限属性クラス>()

    /**
     *
     */
    fun 権限対象手続き_権限があるか() = 権限対象手続き_権限 != null

    /**
     *
     */
    fun 権限対象手続き目録_階層別権限があるか(階層番号: Int) = 権限対象手続き目録_階層別権限.containsKey(階層番号)

    /**
     *
     */
    fun 権限対象手続きグループ_手続き権限があるか() = 権限対象手続きグループ_手続き権限 != null

    /**
     *
     */
    fun 権限対象手続きグループ_階層別権限があるか(階層番号: Int) = 権限対象手続きグループ_階層別権限.containsKey(階層番号)

    /**
     *
     */
    fun 権限対象手続き_権限を返す() = 権限対象手続き_権限

    /**
     *
     */
    fun 権限対象手続き目録_階層別権限を返す(階層番号: Int) = 権限対象手続き目録_階層別権限[階層番号]

    /**
     *
     */
    fun 権限対象手続きグループ_手続き権限を返す() = 権限対象手続きグループ_手続き権限

    /**
     *
     */
    fun 権限対象手続きグループ_階層別権限を返す(階層番号: Int) = 権限対象手続きグループ_階層別権限[階層番号]

    /**
     *
     */
    private fun 権限対象別データをクリアする() {
        権限対象手続き_権限 = null
        権限対象手続き目録_階層別権限.clear()
        権限対象手続きグループ_手続き権限 = null
        権限対象手続きグループ_階層別権限.clear()
    }

    /**
     *
     */
    fun 実行権限設定データを整理する(手続き目録階層: データ整理用手続き目録階層クラス): Boolean {
        if (利用対象側か()) {
            // 利用者側の当事者のみ整理する
            return false
        }

        権限対象別データをクリアする()

        利用対象別権限データマップ_手続き.values.forEach {
            if (権限対象手続き_権限 == null)
                権限対象手続き_権限 = it.権限を返す().複製する()
            else
            // 手続きに対しては１：１なので、２つ以上あればエラー
                throw 実行権限チェックエラークラス(this.javaClass, メッセージID一覧.APPPRM_E_0050, it.実行権限設定データの識別子を返す())
        }

        利用対象別権限データマップ_手続き目録.values.forEach {
            val 階層番号 = (it.利用対象を返す().当事者を返す() as データ整理用手続き目録クラス).階層番号を返す()
            val 権限 = it.権限を返す()
            if (権限対象手続き目録_階層別権限.containsKey(階層番号)) {
                // 手続き目録に対しても１：１なので、２つ以上あればエラー
                throw 実行権限チェックエラークラス(this.javaClass, メッセージID一覧.APPPRM_E_0050, it.実行権限設定データの識別子を返す())
            } else {
                権限対象手続き目録_階層別権限[階層番号] = 権限.複製する()
            }
        }

        利用対象別権限データマップ_手続きグループ.values.forEach {
            val 手続きグループ = (it.利用対象を返す().当事者を返す() as データ整理用手続きグループクラス)
            val 権限 = it.権限を返す()
            if (手続きグループ.やりとり当事者がメンバーにいるか()) {
                if (権限対象手続きグループ_手続き権限 == null)
                    権限対象手続きグループ_手続き権限 = it.権限を返す().複製する()
                else
                // 対象がグループの場合は、所属メンバー単位で一括りにされるため、権限は合算することになる
                    権限対象手続きグループ_手続き権限?.属性を加算した結果で更新する(権限)
            }
            for (階層番号 in 権限管理定数.目録階層番号開始値..手続き目録階層.目録階層数を返す()) {
                if (手続きグループ.この階層番号の手続き目録がメンバーにいるか(階層番号)) {
                    if (権限対象手続きグループ_階層別権限.containsKey(階層番号)) {
                        // 対象がグループの場合は、所属メンバー単位で一括りにされるため、権限は合算することになる
                        権限対象手続きグループ_階層別権限[階層番号]?.属性を加算した結果で更新する(権限)
                    } else {
                        権限対象手続きグループ_階層別権限[階層番号] = 権限.複製する()
                    }
                }
            }
        }
        return true
    }

    /**
     *
     */
    fun 設定されている権限設定データ数を返す() = 権限データ配列.size

    /**
     *
     */
    fun 権限設定データが設定されているか() = 設定されている権限設定データ数を返す() > 0

    /**
     *
     */
    fun 権限設定データのループ処理をする(アクション: (データ整理用実行権限設定データクラス) -> Unit) {
        権限データ配列.forEach(アクション)
    }

    /**
     *
     */
    fun 種別が一致しているか(実行権限利用者種別: 実行権限利用者種別一覧): Boolean = 実行権限利用者種別を返す() == 実行権限利用者種別

    /**
     *
     */
    fun 種別が一致しているか(実行権限利用対象種別: 実行権限利用対象種別一覧): Boolean = 実行権限利用対象種別を返す() == 実行権限利用対象種別

    /**
     *
     */
    fun 種別と識別子が一致しているか(実行権限利用者種別: 実行権限利用者種別一覧, 識別子: Int): Boolean = 種別が一致しているか(実行権限利用者種別) && 識別子を返す() == 識別子

    /**
     *
     */
    fun 種別と識別子が一致しているか(実行権限利用対象種別: 実行権限利用対象種別一覧, 識別子: Int): Boolean = 種別が一致しているか(実行権限利用対象種別) && 識別子を返す() == 識別子

    /**
     *
     */
    fun 識別子を返す() = 識別子

    /**
     *
     */
    fun 利用者側か() = 実行権限当事者種別を返す() == 利用者

    /**
     *
     */
    fun 利用対象側か() = 実行権限当事者種別を返す() == 利用対象

    /**
     *
     */
    fun 実行権限当事者種別を返す() = 当事者種別

    /**
     *
     */
    open fun 実行権限利用者種別を返す(): 実行権限利用者種別一覧? = null

    /**
     *
     */
    open fun 実行権限利用対象種別を返す(): 実行権限利用対象種別一覧? = null

    /**
     *
     */
    open fun 権限データを追加する(権限データ: データ整理用実行権限設定データクラス): Boolean {
        val 権限データ識別子 = 権限データ.実行権限設定データの識別子を返す()
        return if (権限データ識別子セット.contains(権限データ識別子)) {
            // この権限設定データは登録済み
            false
        } else {
            // 権限設定データの利用者側、あるいは利用対象側が、当クラスの種別＋識別子と一致するかチェックする
            val 識別子 = 識別子を返す()
            var 該当するか =
                if (利用者側か()) {
                    権限データ.利用者と同じか(実行権限利用者種別を返す() ?: 実行権限利用者種別一覧.不明, 識別子)
                } else if (利用対象側か()) {
                    権限データ.利用対象と同じか(実行権限利用対象種別を返す() ?: 実行権限利用対象種別一覧.不明, 識別子)
                } else
                    false

            if (!該当するか) {
                // この権限設定データは当クラスとは関係ない
                false
            } else {
                権限データ配列 += 権限データ
                権限データ識別子セット += 権限データ識別子
                if (利用者側か()) {
                    // 権限設定データの利用者側が当クラスだった場合、利用対象別に実行権限設定データを振り分ける
                    val 利用対象ID = 権限データ.利用対象IDを返す()
                    when (権限データ.利用対象種別を返す()) {
                        手続き -> 利用対象別権限データマップ_手続き[利用対象ID] = 権限データ
                        手続き目録 -> 利用対象別権限データマップ_手続き目録[利用対象ID] = 権限データ
                        手続きグループ -> 利用対象別権限データマップ_手続きグループ[利用対象ID] = 権限データ
                        else -> {}
                    }
                    true
                } else if (利用対象側か()) {
                    // 利用対象側では実行権限データは配分しない。（利用対象を起点に実行権限チェックはしないため）
                    false
                } else {
                    false
                }
            }
        }
    }

    /**
     *
     */
    fun 権限属性値を返す(利用対象: データ整理用利用対象クラス): 権限属性クラス? {
        return 権限属性値を返す(利用対象.利用対象種別を返す(), 利用対象.利用対象IDを返す())
    }

    /**
     *
     */
    fun 権限属性値を返す(利用対象種別: 実行権限利用対象種別一覧, 利用対象ID: Int): 権限属性クラス? {
        return when (利用対象種別) {
            手続き -> 利用対象別権限データマップ_手続き[利用対象ID]?.権限を返す()
            手続き目録 -> 利用対象別権限データマップ_手続き[利用対象ID]?.権限を返す()
            手続きグループ -> 利用対象別権限データマップ_手続き[利用対象ID]?.権限を返す()
            else -> null
        }
    }

    /**
     *
     */
    fun クリアする() {
        権限データ配列.clear()
        権限データ識別子セット.clear()
        利用対象別権限データマップ_手続き.clear()
        利用対象別権限データマップ_手続き目録.clear()
        利用対象別権限データマップ_手続きグループ.clear()
    }
}