package name.uroak.uroak_service_center.sysad.services

import name.uroak.uroak_service_center.base.services.汎用サービスクラス
import name.uroak.uroak_service_center.shared.base.execution.手続きパスクラス
import name.uroak.uroak_service_center.shared.base.util.*
import name.uroak.uroak_service_center.shared.constants.message.メッセージID一覧
import name.uroak.uroak_service_center.shared.error.exception.実行権限チェックエラークラス
import name.uroak.uroak_service_center.shared.util.extension.*
import name.uroak.uroak_service_center.shared.util.log.ログ
import name.uroak.uroak_service_center.shared.util.tool.型道具箱
import name.uroak.uroak_service_center.shared.util.tool.文字列道具箱
import name.uroak.uroak_service_center.sysad.constants.取得データ名
import name.uroak.uroak_service_center.sysad.entity.*
import name.uroak.uroak_service_center.sysad.repository.実行権限チェックリポジトリ
import name.uroak.uroak_service_center.sysad.utils.*
import name.uroak.uroak_service_center.sysad.utils.実行権限当事者種別一覧
import name.uroak.uroak_service_center.sysad.utils.実行権限設定クラス
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Isolation
import org.springframework.transaction.annotation.Propagation
import org.springframework.transaction.annotation.Transactional

/**
 *
 */
@Service
class 実行権限チェックサービスクラス : 汎用サービスクラス {

    /***/
    @Autowired
    lateinit var 実行権限チェックリポジトリ: 実行権限チェックリポジトリ

    /**
     *
     */
    constructor() : super("実行権限チェックサービス")

    /**
     *
     */
    private fun チェック例外をスローする(メッセージID: メッセージID一覧, vararg パラメータ: Any): Nothing {
        エラーログを出力する(メッセージID, *パラメータ)
        throw 実行権限チェックエラークラス(this.javaClass, メッセージID, *パラメータ)
    }

    /**
     *
     */
    private fun チェック例外をスローする(原因となる例外: Throwable, メッセージID: メッセージID一覧, vararg パラメータ: Any): Nothing {
        エラーログを出力する(原因となる例外, メッセージID, *パラメータ)
        throw 実行権限チェックエラークラス(this.javaClass, 原因となる例外, メッセージID, *パラメータ)
    }

    /**
     *
     */
    @Transactional(
        isolation = Isolation.READ_COMMITTED,
        propagation = Propagation.REQUIRED,
        readOnly = false
    )
    fun 実行権限をチェックする(ユーザトークン: String, コントローラ情報: コントローラ情報クラス, 手続きパス: 手続きパスクラス): 実行権限チェック結果データクラス {

        実行ログを出力する("実行権限チェックを開始します。")

        val 道具箱 = 実行権限チェック道具箱クラス()

        try {

            実行ログを出力する("会員と手続きをセットします。")

            道具箱.会員と手続きをセットする(
                手続き情報 = 手続き情報を作成する(コントローラ情報, 手続きパス),
                会員情報 = 会員情報を作成する(ユーザトークン)
            )

            実行ログを出力する("会員：【%s】、手続き：【%s】", 道具箱.会員情報の詳細を文字列化する(), 道具箱.手続き情報の詳細を文字列化する())

            if (事前チェックを行う(道具箱)) {

                実行ログを出力する("事前チェックの結果、実行可能と判定されたので、正常終了します。")

                // trueが返された場合は、実行可能と判定されたことになるので、これ以降のチェックは不要
                // 実行不可が確定した場合は例外（実行権限チェックエラークラス）がスローされるのでcatch節で処理する
                // falseが返された場合は、実行可不可の判断が確定できなかったことを意味するので、引き続き、チェックを行う必要がある
                return 道具箱.正常チェック結果を作成する()
            }

            実行ログを出力する("事前チェックでは実行可能かどうかわからなかったので、より詳しい実行権限設定チェックを始めます。")

            return if (実行権限設定をもとに実行権限チェックを行う(道具箱)) {
                実行ログを出力する("実行権限設定データのチェックの結果、実行可能と判定されたので、正常終了します。")

                道具箱.正常チェック結果を作成する()

            } else {
                実行ログを出力する("実行権限設定データのチェックの結果、実行不可と判定されたので、エラー終了します。")

                エラーログを出力する(
                    メッセージID一覧.APPPRM_E_0039,
                    道具箱.会員情報の詳細を文字列化する(),
                    道具箱.手続き情報の詳細を文字列化する()
                )

                道具箱.エラーチェック結果を作成する()
            }

        } catch (チェックエラー: 実行権限チェックエラークラス) {
            実行ログを出力する("チェック処理の途中でエラー、あるいは実行不可と判定されたので、エラー終了します。")

            エラーログを出力する(
                チェックエラー,
                メッセージID一覧.APPPRM_E_0039,
                道具箱.会員情報の詳細を文字列化する(),
                道具箱.手続き情報の詳細を文字列化する()
            )

            return 道具箱.エラーチェック結果を作成する()

        } catch (その他の例外: Throwable) {

            実行ログを出力する("チェック例外以外の例外を補足しました。")

            エラーログを出力する(
                その他の例外,
                メッセージID一覧.CMN_E_0002,
                "実行権限チェック処理の途中で例外が発生しました。"
            )

            throw その他の例外
        }
    }

    /**
     * 当該メソッドでは、会員情報、手続き情報、実行権限データをもとに実行可能か判定する。
     * ※ここで判定できなかった場合は、別メソッドで実行権限設定データをもとに実行可能か判定することになる。
     * 実行可能と判定したらtrueを返す。
     * 実行可不可の判断ができない場合はfalseを返す。（実行権限設定データから判定を行うことになる）
     * 実行不可が確定した場合は例外（実行権限チェックエラークラス）をスローする。
     */
    private fun 事前チェックを行う(道具箱: 実行権限チェック道具箱クラス): Boolean {

        実行ログを出力する("事前チェックを行います。")

        val 会員情報: 会員情報クラス = 道具箱.会員情報を返す()
        val 手続き情報: 手続き情報クラス = 道具箱.手続き情報を返す()

        実行ログを出力する("利用者の会員がログイン不可かどうかチェックを行います。")

        if (会員情報.ログイン不可の会員か()) {

            実行ログを出力する("利用者の会員がログイン不可だったので実行不可としてエラー終了。")

            // ログイン不可の場合の利用者は、そもそもアクセスできないので無条件で実行不可
            チェック例外をスローする(メッセージID一覧.APPPRM_E_0044)
        } else {
            実行ログを出力する("ログイン不可ではありません。")
        }

        val コントローラ情報 = 手続き情報.コントローラ情報を返す()

        実行ログを出力する("対象手続きのコントローラが使用中止かどうかチェックを行います。")

        if (コントローラ情報.使用中止か()) {

            実行ログを出力する("対象手続きのコントローラが使用中止の設定になっていたので実行不可としてエラー終了。")

            // コントローラが使用中止の場合は、配下の手続きは、どの権限でも実行できない
            チェック例外をスローする(メッセージID一覧.APPPRM_E_0045)
        } else {
            実行ログを出力する("使用中止ではありません。")
        }

        実行ログを出力する("利用者の会員がシステム管理者かどうかチェックを行います。")

        if (会員情報.システム管理者か()) {

            実行ログを出力する("利用者の会員がシステム管理者だったので実行可能として正常終了。")

            // システム管理者は全ての手続きが実行可能
            return true
        } else {
            実行ログを出力する("システム管理者ではありません。")
        }

        実行ログを出力する("対象手続きのコントローラがシステム管理API用のものかどうかチェックを行います。")

        if (コントローラ情報.システム管理用か()) {

            実行ログを出力する("対象手続きのコントローラがシステム管理API用のものだったので実行不可としてエラー終了。")

            // システム管理手続きはシステム管理者以外は実行できないので、この時点ではシステム管理者ではないから、実行不可
            チェック例外をスローする(メッセージID一覧.APPPRM_E_0046)
        } else {
            実行ログを出力する("システム管理用の手続き（API）ではありません。")
        }

        実行ログを出力する("利用者の会員がサービス管理者かどうかチェックを行います。")

        if (会員情報.サービス管理者か()) {

            実行ログを出力する("利用者の会員がサービス管理者だったので実行可能として正常終了。")

            // サービス管理者の場合、システム管理手続き以外は実行可能
            return true
        } else {
            実行ログを出力する("サービス管理者ではありません。")
        }

        val 手続き処理種別 = 手続き情報.手続き処理種別を返す()

        実行ログを出力する("対象手続きの処理種別：%s", 手続き処理種別.name)

        実行ログを出力する("利用者会員と対象手続きの間で設定されている権限データを取得します。")

        // 実行権限データがない場合は、実行権限設定情報をもとに実行権限チェックを行うことになるため、ここでは判定できない
        val 権限 = 実行権限データを取得する(道具箱)
        if (権限 == null) {
            実行ログを出力する("権限データが見つかりませんでした。")
            return false
        } else {
            実行ログを出力する("権限データが見つかりました。権限属性：%s", 権限.文字列化する())
        }

        実行ログを出力する("取得した権限データをもとに権限の判定を行います。")

        // 実行権限データをもとに判定する
        if (!対象手続きを実行可能かチェックする(手続き処理種別, 権限)) {

            実行ログを出力する("判定の結果、実行不可と判定されました。")

            // 実行権限データがあって、実行不可の設定になっていたら、実行不可と判定する
            チェック例外をスローする(
                メッセージID一覧.APPPRM_E_0048,
                手続き処理種別.name,
                権限.文字列化する()
            )
        }

        実行ログを出力する("事前チェックの結果、実行可能と判定されました。")

        return true
    }

    /**
     *
     */
    private fun 実行権限設定をもとに実行権限チェックを行う(道具箱: 実行権限チェック道具箱クラス): Boolean {
        実行ログを出力する("実行権限設定データをもとに実行権限チェックを行います。")

        // 1. 対象手続きの目録階層を取得する
        実行ログを出力する("対象手続きの目録階層を取得します。")
        道具箱.手続き目録階層配列からデータをセットする(手続き目録階層を取得する(道具箱))

        // 2. 手続き目録階層と対象手続きに紐づく手続きグループを収集する
        // ※収集した手続きグループのメンバーに手続きグループがある場合は展開して手続きと目録だけにしておく
        実行ログを出力する("手続き目録階層と対象手続きに紐づく手続きグループを収集します。")
        指定手続き及び目録階層が所属する手続きグループを収集しセットする(道具箱)

        // 3. 会員が、対象限定管理者グループ（管理者グループテーブル）に登録されているかチェックする
        // ※登録管理者グループと、対象手続き、手続き目録階層、手続きグループとの間の実行権限設定データを収集する
        実行ログを出力する("利用者の会員が、対象限定管理者グループ（管理者グループテーブル）に登録されているかチェックします。")
        val 対象限定管理者としての権限 = 道具箱.対象限定管理者としての実行権限をチェックする(対象限定管理者の実行権限設定データを取得する(道具箱))
        if (対象限定管理者としての権限 != null) {
            // 3-1. 権限データを登録し、終了する。（登録する権限データは全ての権限属性を１にすること）
            実行権限データを登録する(道具箱, 対象限定管理者としての権限)

            実行ログを出力する("実行権限データを登録しました。権限属性はすべて1です。")

            return true
        }

        // 4. 会員の目録階層を取得する
        実行ログを出力する("会員の目録階層を取得します。")
        道具箱.会員目録階層配列からデータをセットする(会員目録階層を取得する(道具箱))

        // 5. 会員目録階層と会員に紐づく会員グループを収集する
        // ※収集した会員グループのメンバーに会員グループがある場合は展開して会員と目録だけにしておく
        実行ログを出力する("会員目録階層及び会員に紐づく会員グループを収集します。")
        指定会員及び目録階層が所属する会員グループを収集しセットする(道具箱)

        // 6. 会員、会員目録、会員グループと対象手続き、手続き目録階層、手続きグループとの間の実行権限設定データを収集する
        道具箱.利用者と利用対象との間で有効な実行権限設定を取得するための準備をする(実行権限設定レコードを収集する(道具箱))

        // 7. 権限データをチェックする。
        val 権限属性 = 道具箱.利用者と利用対象との間で有効な実行権限設定を取得する()

        if (権限属性 != null) {
            // 8.1 権限データが取得できた場合
            実行ログを出力する("実行権限設定データがありました。")

            // 8.2 権限データを登録する
            実行ログを出力する("取得した実行権限設定データをもとに実行権限データを登録します。権限属性：%s", 権限属性.文字列化する())
            実行権限データを登録する(道具箱, 権限属性)

            return 道具箱.対象手続きが実行可能かチェックする(権限属性)

        } else {
            // 9.1 利用者と利用対象との間で権限データが未設定の場合
            実行ログを出力する("実行権限設定データが未登録だったので実行不可と判定し、全て0の権限属性の実行権限データを登録します。")

            // 9.2 実行不可の権限データを登録し、エラー終了する。（権限属性はすべて0とする）
            実行権限データを登録する(道具箱, 権限属性クラス.実行不可の権限属性を作成する())

            実行ログを出力する("エラー終了します。")

            return false
        }
    }

    /**
     *
     */
    private fun 指定会員及び目録階層が所属する会員グループを収集する(道具箱: 実行権限チェック道具箱クラス): List<グループデータクラス> {
        return 所属するグループを収集する(実行権限当事者種別一覧.利用者, 道具箱.会員識別子を返す(), 道具箱.会員目録識別子配列を返す())
    }

    /**
     *
     */
    private fun 指定手続き及び目録階層が所属する手続きグループを収集する(道具箱: 実行権限チェック道具箱クラス): List<グループデータクラス> {
        return 所属するグループを収集する(実行権限当事者種別一覧.利用対象, 道具箱.手続き識別子を返す(), 道具箱.手続き目録識別子配列を返す())
    }

    /**
     *
     */
    private fun 指定会員及び目録階層が所属する会員グループを収集しセットする(道具箱: 実行権限チェック道具箱クラス) {
        道具箱.会員グループ群からデータをセットする(指定会員及び目録階層が所属する会員グループを収集する(道具箱).toMutableList())
    }

    /**
     *
     */
    private fun 指定手続き及び目録階層が所属する手続きグループを収集しセットする(道具箱: 実行権限チェック道具箱クラス) {
        道具箱.手続きグループ群からデータをセットする(指定手続き及び目録階層が所属する手続きグループを収集する(道具箱).toMutableList())
    }

    /**
     *
     */
    private fun 所属するグループを収集する(当事者種別: 実行権限当事者種別一覧, 識別子: Int, 目録識別子配列: MutableList<Int>): MutableList<グループデータクラス> {

        // 会員及び、その会員目録階層の各目録が所属する会員グループを収集する。
        // グループメンバーに会員グループがある場合、その会員グループメンバーのメンバーに利用者の会員あるいは会員目録階層の目録があるかもしれないので、
        // 会員グループをメンバーに持つ会員グループも収集している。
        val グループセット = mutableMapOf<Int, グループデータクラス>()

        with(所属するグループのデータを収集する(当事者種別, 識別子, 目録識別子配列)) {
            this.forEach {
                val グループ識別子 = it.Int値で取得する_NULL不可(取得データ名.グループ識別子)
                with(
                    グループセット[グループ識別子] ?: グループデータクラス(
                        グループ識別子 = グループ識別子,
                        グループ名称 = it.文字列値で取得する(取得データ名.グループ名称)
                    )
                ) {
                    val 対象グループ = this
                    グループセット[グループ識別子] = 対象グループ

                    with(グループメンバーデータを作成する(当事者種別, it)) {
                        対象グループ.グループ存在フラグ = グループメンバーがグループかどうかチェックする(当事者種別, this)
                        対象グループ.メンバー += this
                    }
                }
            }
        }

        // メンバーに会員グループがある会員グループの、会員グループメンバーを会員と会員目録に展開する。（メンバーに会員グループがなくなるまで繰り返す）
        // その結果、利用者の会員及び、その会員目録階層の各目録のいずれもメンバーにない会員グループは破棄する。
        return mutableListOf<グループデータクラス>().apply {
            グループセット.forEach { (_: Int, グループ: グループデータクラス) ->
                if (グループ.グループ存在フラグ) {
                    var 展開メンバー有無 = true
                    with(mutableListOf<グループメンバーデータクラス>()) {
                        val 展開メンバー配列 = this
                        // 展開する際、利用者の会員及び、その会員目録階層の目録をメンバーに持つ会員グループのみ返している
                        // そのため、展開した結果、利用者の会員及び、その会員目録階層の目録をメンバーに持たない会員グループは空で返ってくる
                        with(グループメンバーのグループを展開する(当事者種別, グループ, 識別子, 目録識別子配列)) {
                            this.forEach {
                                展開メンバー配列 += グループメンバーデータを作成する(当事者種別, it)
                            }
                        }
                        if (展開メンバー配列.isEmpty()) {
                            展開メンバー有無 = false
                        } else {
                            グループ.メンバー = 展開メンバー配列
                            グループ.グループ存在フラグ = false
                        }
                    }
                    // 展開後にメンバーが空になったグループは、利用者の会員及び、その会員目録階層の目録がメンバーに含まれていないものなので破棄する
                    if (展開メンバー有無) {
                        this += グループ
                    }
                } else {
                    this += グループ
                }
            }
        }
    }

    /**
     *
     */
    private fun 所属するグループのデータを収集する(当事者種別: 実行権限当事者種別一覧, 識別子: Int, 目録識別子配列: List<Int>): List<Map<String, Any?>> {
        return when (当事者種別) {
            実行権限当事者種別一覧.利用者 -> 実行権限チェックリポジトリ.指定会員が所属する会員グループを収集する(識別子, 目録識別子配列)
            実行権限当事者種別一覧.利用対象 -> 実行権限チェックリポジトリ.指定手続きが所属する手続きグループを収集する(識別子, 目録識別子配列)
            実行権限当事者種別一覧.不明 -> チェック例外をスローする(メッセージID一覧.CMN_E_0002, "当事者種別が不明になっています。")
        }
    }

    /**
     *
     */
    private fun グループメンバーがグループかどうかチェックする(当事者種別: 実行権限当事者種別一覧, 追加メンバー: グループメンバーデータクラス): Boolean {
        return when (当事者種別) {
            実行権限当事者種別一覧.利用者 -> (追加メンバー as 会員グループメンバーデータクラス).メンバー種別 == 会員メンバー種別一覧.会員グループ
            実行権限当事者種別一覧.利用対象 -> (追加メンバー as 手続きグループメンバーデータクラス).メンバー種別 == 手続きメンバー種別一覧.手続きグループ
            実行権限当事者種別一覧.不明 -> チェック例外をスローする(メッセージID一覧.CMN_E_0002, "当事者種別が不明になっています。")
        }
    }

    /**
     *
     */
    private fun グループメンバーのグループを展開する(当事者種別: 実行権限当事者種別一覧, グループ: グループデータクラス, 識別子: Int, 目録識別子配列: MutableList<Int>):
            List<Map<String, Any?>> {
        return when (当事者種別) {
            実行権限当事者種別一覧.利用者 -> 実行権限チェックリポジトリ.会員グループを展開する(グループ.グループ識別子, 識別子, 目録識別子配列)
            実行権限当事者種別一覧.利用対象 -> 実行権限チェックリポジトリ.手続きグループを展開する(グループ.グループ識別子, 識別子, 目録識別子配列)
            実行権限当事者種別一覧.不明 -> チェック例外をスローする(メッセージID一覧.CMN_E_0002, "当事者種別が不明になっています。")
        }
    }

    /**
     *
     */
    private fun グループメンバーデータを作成する(当事者種別: 実行権限当事者種別一覧, 取得データ: Map<String, Any?>): グループメンバーデータクラス {
        return when (当事者種別) {
            実行権限当事者種別一覧.利用者 -> {
                会員グループメンバーデータクラス(
                    メンバー種別 = 会員メンバー種別一覧.JSONフィールド値を列挙定数に変換する(取得データ.Int値で取得する_NULL不可(取得データ名.メンバー種別)),
                    メンバー識別子 = 取得データ.Int値で取得する_NULL不可(取得データ名.メンバー識別子)
                )
            }
            実行権限当事者種別一覧.利用対象 -> {
                手続きグループメンバーデータクラス(
                    メンバー種別 = 手続きメンバー種別一覧.JSONフィールド値を列挙定数に変換する(取得データ.Int値で取得する_NULL不可(取得データ名.メンバー種別)),
                    メンバー識別子 = 取得データ.Int値で取得する_NULL不可(取得データ名.メンバー識別子)
                )
            }
            実行権限当事者種別一覧.不明 -> チェック例外をスローする(メッセージID一覧.CMN_E_0002, "当事者種別が不明になっています。")
        }
    }

    /**
     *
     */
    private fun 会員目録階層を取得する(道具箱: 実行権限チェック道具箱クラス): MutableList<会員目録階層データクラス> {
        val 会員目録階層 = mutableListOf<会員目録階層データクラス>()
        with(実行権限チェックリポジトリ.会員目録階層を取得する(道具箱.会員識別子を返す())) {
            this.forEach {
                会員目録階層 += 会員目録階層データクラス(
                    階層番号 = it.Int値で取得する_NULL不可(取得データ名.階層番号),
                    識別子 = it.Int値で取得する_NULL不可(取得データ名.識別子),
                    名称 = it.文字列値で取得する(取得データ名.名称),
                    親目録識別子 = it.Int値で取得する(取得データ名.親目録識別子)
                )
            }
        }
        return 会員目録階層
    }

    /**
     *
     */
    private fun 手続き目録階層を取得する(道具箱: 実行権限チェック道具箱クラス): MutableList<手続き目録階層データクラス> {
        val 手続き目録階層 = mutableListOf<手続き目録階層データクラス>()
        with(実行権限チェックリポジトリ.手続き目録階層を取得する(道具箱.手続き識別子を返す())) {
            this.forEach {
                手続き目録階層 += 手続き目録階層データクラス(
                    階層番号 = it.Int値で取得する_NULL不可(取得データ名.階層番号),
                    識別子 = it.Int値で取得する_NULL不可(取得データ名.識別子),
                    名称 = it.文字列値で取得する(取得データ名.名称),
                    親目録識別子 = it.Int値で取得する(取得データ名.親目録識別子)
                )
            }
        }
        return 手続き目録階層
    }

    /**
     *
     */
    private fun 対象限定管理者の実行権限設定データを取得する(道具箱: 実行権限チェック道具箱クラス): MutableList<実行権限設定クラス> {
        val 実行権限設定データ配列 = mutableListOf<実行権限設定クラス>()
        with(
            実行権限チェックリポジトリ.対象限定管理者の実行権限設定データを取得する(
                道具箱.会員識別子を返す(),
                道具箱.手続き識別子を返す(),
                道具箱.手続き目録識別子配列を返す(),
                道具箱.手続きグループ識別子配列を返す()
            )
        ) {
            this.forEach {
                実行権限設定データ配列 += 実行権限設定クラス(it.toMutableMap())
            }
        }
        return 実行権限設定データ配列
    }

    /**
     *
     */
    private fun 実行権限データを登録する(道具箱: 実行権限チェック道具箱クラス, 権限データ: 権限属性クラス) {
        実行権限チェックリポジトリ.実行権限データを登録する(道具箱.会員識別子を返す(), 道具箱.手続き識別子を返す(), 権限データ.権限値を返す())
    }

    private fun 実行権限設定レコードを収集する(道具箱: 実行権限チェック道具箱クラス): List<Map<String, Any?>> {
        return 実行権限チェックリポジトリ.実行権限設定データを取得する(
            道具箱.会員識別子を返す(),
            道具箱.会員目録識別子配列を返す(),
            道具箱.会員グループ識別子配列を返す(),
            道具箱.手続き識別子を返す(),
            道具箱.手続き目録識別子配列を返す(),
            道具箱.手続きグループ識別子配列を返す()
        )
    }


    /**
     * 実行権限データは利用会員と利用対象手続きの間に設定されるデータで、実行権限設定データをもとに作成登録される
     */
    private fun 実行権限データを取得する(道具箱: 実行権限チェック道具箱クラス): 権限属性クラス? {

        val 会員識別子 = 道具箱.会員識別子を返す()
        val 手続き識別子 = 道具箱.手続き識別子を返す()

        val 実行権限データ配列 = 実行権限データを取得する(会員識別子, 手続き識別子)

        return when (実行権限データ配列.size) {
            // 権限データ未登録
            0 -> null
            // 権限データ登録済み。権限チェックの結果を返す
            1 -> 実行権限データ配列[0].権限
            // 権限データ複数登録　→　DBの設定ミス？（通常はあり得ないはず）
            else -> チェック例外をスローする(メッセージID一覧.APPPRM_E_0047, 会員識別子, 手続き識別子)
        }
    }

    /**
     *
     */
    private fun 対象手続きを実行可能かチェックする(手続き処理種別: 手続き処理種別一覧, 権限: 権限属性クラス): Boolean {
        return 権限.実行可能かチェックする(手続き処理種別)
    }

    /**
     *
     */
    private fun 実行権限データを取得する(会員識別子: Int? = null, 手続き識別子: Int? = null): MutableList<実行権限データクラス> {
        val 実行権限データ配列 = mutableListOf<実行権限データクラス>()

        with(実行権限チェックリポジトリ.実行権限を取得する(会員識別子, 手続き識別子)) {
            forEach {
                実行権限データ配列 += 実行権限データクラス(
                    会員識別子 = it.Int値で取得する(取得データ名.会員識別子),
                    手続き識別子 = it.Int値で取得する(取得データ名.手続き識別子),
                    権限 = 権限属性クラス(it.Int値で取得する_NULL不可(取得データ名.権限))
                )
            }
        }

        return 実行権限データ配列
    }

    /**
     *
     */
    private fun 会員情報を作成する(識別トークン: String): 会員情報クラス {

        実行ログを出力する("会員情報を取得する。識別トークン：%s", 識別トークン)

        val 会員情報配列 = 会員情報を取得する(識別トークン)

        実行ログを出力する("会員情報取得数：%d", 会員情報配列.size)

        when (会員情報配列.size) {
            0 -> {
                会員情報作成エラーをスローする(メッセージID一覧.APPPRM_E_0024, 出力用の識別トークンを編集する(識別トークン))
            }
            1 -> {
                return 会員情報クラス(会員情報配列[0])
            }
            else -> {
                会員情報作成エラーをスローする(メッセージID一覧.APPPRM_E_0025, 出力用の識別トークンを編集する(識別トークン))
            }
        }

    }

    /**
     *
     */
    private fun 会員情報作成エラーをスローする(メッセージID: メッセージID一覧, 識別トークン: String): Nothing {
        チェック例外をスローする(メッセージID, 識別トークン)
    }

    /**
     *
     */
    private fun 出力用の識別トークンを編集する(識別トークン: String): String {
        return if (文字列道具箱.空白文字列か(識別トークン)) "＜未設定＞" else 識別トークン
    }

    /**
     *
     */
    private fun 手続き情報を作成する(コントローラ情報: コントローラ情報クラス, 手続きパス: 手続きパスクラス): 手続き情報クラス {

        実行ログを出力する("手続き情報を取得する。手続きパス：%s", 手続きパス.文字列化する(コントローラ情報))

        val 手続き情報配列 = 手続き情報を取得する(手続きパス)

        実行ログを出力する("手続き情報取得数：%d", 手続き情報配列.size)

        when (手続き情報配列.size) {
            0 -> {
                手続き情報作成エラーをスローする(メッセージID一覧.APPPRM_E_0022, 手続きパス)
            }
            1 -> {
                val 手続き情報 = 手続き情報配列[0]
                if (手続き情報.コントローラ識別子 < 0) {
                    手続き情報作成エラーをスローする(メッセージID一覧.APPPRM_E_0051, 手続きパス)
                }
                return 手続き情報クラス(手続き情報, コントローラ情報, 手続きパス)
            }
            else -> {
                手続き情報作成エラーをスローする(メッセージID一覧.APPPRM_E_0023, 手続きパス)
            }
        }

    }

    /**
     *
     */
    private fun 手続き情報作成エラーをスローする(メッセージID: メッセージID一覧, 手続きパス: 手続きパスクラス): Nothing {
        チェック例外をスローする(
            メッセージID,
            手続きパス.手続きコード,
            手続きパス.手続き補助コード,
            手続きパス.手続き補助コード2
        )
    }

    /**
     *
     */
    fun コントローラ情報を収集する(): List<コントローラデータクラス> {

        try {
            val レコードセット: MutableList<コントローラデータクラス> = mutableListOf()

            with(実行権限チェックリポジトリ.コントローラ情報を収集する()) {
                this.forEach {
                    レコードセット += コントローラデータクラス(
                        識別子 = it.Int値で取得する_NULL不可(取得データ名.識別子),
                        名称 = it.文字列値で取得する_NULL不可(取得データ名.名称),
                        目録識別子 = it.Int値で取得する_NULL不可(取得データ名.目録識別子),
                        目録名称 = it.文字列値で取得する_NULL不可(取得データ名.目録名称),
                        URLパス = it.文字列値で取得する_NULL不可(取得データ名.URLパス),
                        DIコンポーネント名 = it.文字列値で取得する_NULL不可(取得データ名.DIコンポーネント名),
                        クラス名 = it.文字列値で取得する(取得データ名.クラス名),
                        クラスパッケージパス = it.文字列値で取得する(取得データ名.クラスパッケージパス),
                        使用中止 = 型道具箱.Booleanに変換する_NULLはfalseとする(it.Int値で取得する_NULL不可(取得データ名.使用中止)),
                        システム管理用 = 型道具箱.Booleanに変換する_NULLはfalseとする(it.Int値で取得する_NULL不可(取得データ名.システム管理用))
                    )
                }
            }

            return レコードセット

        } catch (エラー: Throwable) {
            チェック例外をスローする(エラー, メッセージID一覧.APPPRM_E_0043)
        }
    }

    /**
     *
     */
    private fun 会員情報を取得する(利用者識別トークン: String): List<会員データクラス> {
        try {
            val レコードセット: MutableList<会員データクラス> = mutableListOf()

            with(実行権限チェックリポジトリ.会員情報を取得する(利用者識別トークン)) {
                this.forEach {
                    レコードセット += 会員データクラス(
                        識別子 = it.Int値で取得する_NULL不可(取得データ名.識別子),
                        目録識別子 = it.Int値で取得する(取得データ名.識別子),
                        目録名称 = it.文字列値で取得する_NULL不可(取得データ名.目録名称),
                        識別トークン = it.文字列値で取得する_NULL不可(取得データ名.識別トークン),
                        名称 = it.文字列値で取得する_NULL不可(取得データ名.名称),
                        備考 = it.文字列値で取得する_NULL不可(取得データ名.備考),
                        ログイン不可 = 型道具箱.Booleanに変換する_NULLはfalseとする(it.Int値で取得する_NULL不可(取得データ名.ログイン不可)),
                        目録存在フラグ = 型道具箱.Booleanに変換する_NULLはfalseとする(it.Int値で取得する_NULL不可(取得データ名.目録存在フラグ)),
                        システム管理者フラグ = 型道具箱.Booleanに変換する_NULLはfalseとする(it.Int値で取得する_NULL不可(取得データ名.システム管理者フラグ)),
                        サービス管理者フラグ = 型道具箱.Booleanに変換する_NULLはfalseとする(it.Int値で取得する_NULL不可(取得データ名.サービス管理者フラグ))
                    )
                }
            }

            return レコードセット
        } catch (エラー: Throwable) {
            チェック例外をスローする(エラー, メッセージID一覧.APPPRM_E_0041)
        }
    }

    /**
     *
     */
    private fun 手続き情報を取得する(手続きパス: 手続きパスクラス): List<手続きデータクラス> {
        return 手続き情報を取得する(手続きパス.手続きコード, 手続きパス.手続き補助コード, 手続きパス.手続き補助コード2)
    }

    /**
     *
     */
    private fun 手続き情報を取得する(手続きコード: String, 手続き補助コード: String?, 手続き補助コード2: String?): List<手続きデータクラス> {
        try {
            val レコードセット: MutableList<手続きデータクラス> = mutableListOf()

            with(実行権限チェックリポジトリ.手続き情報を取得する(手続きコード, 手続き補助コード, 手続き補助コード2)) {
                this.forEach {
                    レコードセット += 手続きデータクラス(
                        識別子 = it.Int値で取得する_NULL不可(取得データ名.識別子),
                        目録識別子 = it.Int値で取得する_NULL不可(取得データ名.目録識別子),
                        目録名称 = it.文字列値で取得する_NULL不可(取得データ名.目録名称),
                        コントローラ識別子 = it.Int値で取得する(取得データ名.コントローラ識別子) ?: -1,
                        コントローラ名称 = it.文字列値で取得する(取得データ名.コントローラ名称) ?: "",
                        手続きコード = it.文字列値で取得する_NULL不可(取得データ名.手続きコード),
                        手続き補助コード = it.文字列値で取得する(取得データ名.手続き補助コード),
                        手続き補助コード2 = it.文字列値で取得する(取得データ名.手続き補助コード2),
                        処理種別 = 手続き処理種別一覧.カラム値を列挙定数に変換する(it.Int値で取得する_NULL不可(取得データ名.処理種別)),
                        名称 = it.文字列値で取得する_NULL不可(取得データ名.名称),
                        備考 = it.文字列値で取得する(取得データ名.備考),
                    )
                }
            }

            return レコードセット
        } catch (エラー: Throwable) {
            チェック例外をスローする(エラー, メッセージID一覧.APPPRM_E_0042)
        }
    }

}